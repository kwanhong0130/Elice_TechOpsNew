import streamlit as st
import requests
import time
import pandas as pd
import json
import copy

from loguru import logger
from datetime import datetime
from st_aggrid import AgGrid
from st_aggrid.grid_options_builder import GridOptionsBuilder
from st_aggrid.shared import GridUpdateMode
from st_aggrid import ColumnsAutoSizeMode

def app():
    if 'course_fetch_df' not in st.session_state:
        logger.info('fetch df not in session')
        st.session_state['course_fetch_df'] = pd.DataFrame()

    # Set the API endpoint URL
    base_url = "https://api-rest.elice.io"

    auth_login_endpoint = "/global/auth/login/"
    org_get_endpoint = "/global/organization/get/" # org_id or organization_short_name required

    st.markdown("""
    <style>
    div.stButton > button:first-child {
    background-color: #A961DC; color:white;
    }
    </style>""", unsafe_allow_html=True)

    st.header('‚öíÔ∏è Í≥ºÎ™©Î™Ö ÏùºÍ¥Ñ Î≥ÄÍ≤Ω')

    st.markdown(
        """
        ### Ops overview
        #### ÏûëÏóÖÏù¥ ÏàòÌñâÌïòÎäî ÎÇ¥Ïö©(ÏÇ¨Ïö©Ïûê)
        Î™©Ï†Å
        - Í∏∞Í¥ÄÏóê Îì±Î°ùÎêú Í≥ºÎ™©Îì§Ïùò Ï†ïÎ≥¥Î•º ÏùºÍ¥ÑÏ†ÅÏúºÎ°ú ÏàòÏ†ïÌïúÎã§.

        Í∏∞Ï°¥Î∞©Ïãù 1Ô∏è‚É£
        - Í≥ºÎ™©ÎßàÎã§ Îì§Ïñ¥Í∞ÄÏÑú Î≥ÄÍ≤ΩÌïòÍ≥† Ïã∂ÏùÄ ÏÑ§Ï†ïÍ∞íÏúºÎ°ú ÌïúÎïÄÌïúÎïÄ Î∞îÍæºÎã§. üëÄü§öüí¶

        ‚ñ∂Ô∏è ÏûêÎèôÌôî Î∞©Ïãù (ÎØ∏Ï†ï)
        1) Ìï¥Îãπ Í∏∞Í¥ÄÏùò Í≥ºÎ™© ÏÑ§Ï†ï Í∞íÏùò ÏóëÏÖÄ ÌååÏùºÏùÑ Îã§Ïö¥Î°úÎìú Î∞õÎäîÎã§ -> ÏóëÏÖÄÏóêÏÑú ÏùºÍ¥ÑÏ†ÅÏúºÎ°ú ÏàòÏ†ïÌïòÏó¨ Îã§Ïãú ÏóÖÎ°úÎìú ÌïúÎã§.
        2) ÏõπÏóêÏÑú ÏùºÍ¥ÑÏ†ÅÏúºÎ°ú Î≥ÄÍ≤ΩÌïòÍ≥† Ïã∂ÏùÄ Í≥ºÎ™© ÏÑ§Ï†ï Í∞íÏùÑ ÏÑ†ÌÉùÌïúÎã§(ÏúÑÏ†Ø ÌôúÏö©) -> Î≥ÄÍ≤ΩÌïòÍ≥† Ïã∂ÏùÄ Í≥ºÎ™©ÏùÑ ÏúÑÏ†ØÏóêÏÑú ÏÑ†ÌÉùÌïúÎã§ -> Ï†ÅÏö© Î≤ÑÌäºÏúºÎ°ú Î≥ÄÍ≤ΩÏûëÏóÖ Ïã§Ìñâ

        Background(Context)
        - Í∏∞Í¥Ä Í¥ÄÎ¶¨Ïûê Í≥ÑÏ†ï
        - ÎèôÏùºÌïú ÏÑ§Ï†ï Î≥ÄÍ≤Ω Í∞íÏùÑ Í≥ºÎ™© Ï†ÑÏ≤¥ ÎòêÎäî ÎåÄÎ∂ÄÎ∂ÑÏóê ÏùºÍ¥Ñ ÏàòÏ†ïÌï† ÌïÑÏöîÍ∞Ä ÏûàÍ±∞ÎÇò, Í∑∏Í≤ÉÏù¥ Îçî Ìö®Ïú®Ï†ÅÏùºÎïå

        #### ÏàòÌñâÌïòÎäî ÏûëÏóÖ(Í∞úÎ∞úÏûê)
        1) Í∏∞Í¥ÄÏóê Îì±Î°ùÎêú Í≥ºÎ™© Ï§ë Î≥ÄÍ≤ΩÌïòÍ≥† Ïã∂ÏùÄ Í≥ºÎ™©ÏùÑ ÏÑ†ÌÉùÌïúÎã§.
        2) Î≥ÄÍ≤ΩÌïòÍ≥† Ïã∂ÏùÄ Í≥ºÎ™© ÏÑ§Ï†ï Í∞íÏùÑ Í≤∞Ï†ïÌïúÎã§.
        
        """
        )

    # https://github.com/Socvest/streamlit-pagination
    def get_org_course_list(endpoint, offset, count, sessionkey, **kwargs):
        headers = {
            "Authorization": "Bearer " + sessionkey
        }

        all_course_list = []

        while True:
            # Set the query parameters for the API request
            if not kwargs['filter_title']:
                params = f"?offset={offset}&count={count}&filter_conditions={kwargs['filter_cond']}"
            else:
                params = f"?offset={offset}&count={count}&filter_conditions={kwargs['filter_cond']}&filter_title={kwargs['filter_title']}"
            request_url = base_url+endpoint+params

            # Send the API request with the query parameters
            response = requests.get(request_url, headers=headers)

            # Check if the response status code is OK
            if response.status_code == 200:
                # Get the JSON data from the response
                res_json = response.json()

                # Get the paginated data from the JSON data
                paginated_data = res_json['courses']

                # Do your manipulation on the paginated data here
                all_course_list.extend(paginated_data)

                # Increment the offset parameter for the next API request
                offset += count

                # Check if there are more data to fetch
                if offset >= res_json['course_count']:
                    break
            else:
                # Handle the API request error here
                print('API request error')
                break

        return all_course_list

    def course_setting_edit_single(org_name, course_id, to_change_name, sessionkey):
        edit_course_setting_url = f"https://api-rest.elice.io/org/{org_name}/course/edit/"

        headers = {
            "Authorization": "Bearer " + sessionkey,
            "Content-Type": "application/x-www-form-urlencoded"
        }

        def _update(json, path, new_value):
            obj_ptr = json
            for key in path:
                if key == path[-1]:
                    obj_ptr[key] = new_value
                obj_ptr = obj_ptr[key]

        def _get_course_info(org_name, course_id, sessionkey):
            get_course_info_url = f"https://api-rest.elice.io/org/{org_name}/course/get/?course_id={course_id}"
            headers = {
                "Authorization": "Bearer " + sessionkey
            }

            response = requests.get(get_course_info_url, headers=headers)

            # Check the response status code
            """
            "_result": {
                "status": "ok",
                "reason": null
            }
            """
            if response.status_code == 200:
                # Response was successful, print the response content
                res_json = response.json()
                logger.info(res_json)
            else:
                # Response was not successful, print the error message
                print("Error: " + response.reason)

            return res_json

        # copy from GETed course info; it is assumed that required field already filled
        # global_temp_course_info = course_info_res_json['course']
        global_temp_course_info = _get_course_info(org_name, course_id, sessionkey)['course']
        temp_edit_data = copy.deepcopy(global_temp_course_info)

        temp_edit_data['course_id'] = course_id
        temp_edit_data['title'] = to_change_name
        temp_edit_data['info_summary_visibility_dict'] = json.dumps(temp_edit_data['info_summary_visibility_dict'])
        temp_edit_data['preference'] = json.dumps(temp_edit_data['preference'])
        temp_edit_data['completion_info'] = json.dumps(temp_edit_data['completion_info'])
        # temp_edit_data['attend_info'] = json.dumps(temp_edit_data['attend_info'])
        temp_edit_data['class_times'] = json.dumps(temp_edit_data['class_times'])
        temp_edit_data['objective'] = json.dumps(temp_edit_data['objective'])
        temp_edit_data['faq'] = json.dumps(temp_edit_data['faq'])
        temp_edit_data['target_audience'] = json.dumps(temp_edit_data['target_audience'])
        temp_edit_data['leaderboard_info'] = json.dumps(temp_edit_data['leaderboard_info'])

        payload_data = {'request': json.dumps(temp_edit_data)}

        # https://stackoverflow.com/questions/31168819/how-to-send-an-array-using-requests-post-python-value-error-too-many-values
        logger.info(json.dumps(temp_edit_data, indent = 1, ensure_ascii=False))
        response = requests.post(edit_course_setting_url, headers=headers, data=temp_edit_data)

        if response.status_code == 200:
            res_json = response.json()
        else:
            print("Error: " + response.reason)
            return None

        return res_json


    def get_org(endpoint, org_name, sessionkey):
        headers = {
            "Authorization": "Bearer " + sessionkey
        }

        params = f"?organization_name_short={org_name}"
        request_url = base_url+endpoint+params
        response = requests.get(request_url, headers=headers)

        # Check the response status code
        if response.status_code == 200:
            # Response was successful, print the response content
            res_json = response.json()
        else:
            # Response was not successful, print the error message
            logger.error("Error: " + response.reason)

        return res_json['organization']

    def make_clickable(link):
        # target _blank to open new window
        # extract clickable text to display for your link
        # text = link.split('=')[1]
        return f'<a target="_blank" href="{link}">Í≥ºÎ™© ÎßÅÌÅ¨</a>'

    st.subheader('üîñ Í≥ºÎ™©Î™Ö Î≥ÄÍ≤ΩÌïòÍ∏∞')
    st.write("#### 1Ô∏è‚É£ Í∏∞Í¥ÄÏóêÏÑú Í≥ºÎ™© Î∂àÎü¨Ïò§Í∏∞")

    org_name = st.text_input("Í∏∞Í¥Ä ÎèÑÎ©îÏù∏ Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî. 'https://______.elice.io/", key="change_title_org_input")
    course_list_endpoint = f"/org/{org_name}/course/list/"
    logger.info(f"Current org_short_name is: {org_name}")

    agree = st.checkbox('Í≥ºÎ™©Î™ÖÏùò ÌïÑÌÑ∞ÎßÅ ON/OFF')
    input_filter_title = ""
    if agree:
        input_filter_title = st.text_input("Î∂àÎü¨Ïò¨ Í≥ºÎ™© Î™©Î°ùÏùò Í≥ºÎ™©Î™Ö ÌïÑÌÑ∞ÎßÅ Í∞íÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.", placeholder="'[5Ïõî]'Í≥º Í∞ôÏù¥ ÏûÖÎ†• ÌõÑ ÏóîÌÑ∞Î•º ÎàåÎü¨Ï£ºÏÑ∏Ïöî.")
        st.info(f'ÏûÖÎ†•Ìïú ÌïÑÌÑ∞ ÌÇ§ÏõåÎìú Í∞í: {input_filter_title}')

    # @st.cache_data
    def get_api_data():
        data = get_org_course_list(course_list_endpoint, 0, 10, 
                                st.session_state['sessionkey'],
                                filter_cond={"$and": []},
                                filter_title=input_filter_title) # offset:0 count: 10

        # progress bar
        st.success("Fetched data from API!")  # üëà Show a success message
        return data

    if st.button("Í≥ºÎ™© Î∂àÎü¨Ïò§Í∏∞"):
        if not org_name:
            st.warning("Í≥ºÎ™© Î¶¨Ïä§Ìä∏Î•º Î∂àÎü¨Ïò¨ Í∏∞Í¥ÄÏùò Í∏∞Í¥ÄÎ™ÖÏù¥ ÏûÖÎ†•ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. ‚õîÔ∏è")
        else:
            org_info = get_org(org_get_endpoint, org_name, st.session_state['sessionkey'])
            st.write(f"#### {org_info['name']} Í≥ºÎ™© Î¶¨Ïä§Ìä∏")
            course_infos = get_api_data() # course/list -> ['courses]

            course_names = []
            course_ids = []
            course_urls = []
            for course in course_infos:
                course_id_str = str(course['id'])
                course_names.append(course['title'])
                course_ids.append(course_id_str)
                course_urls.append(f'http://{org_name}.elice.io/courses/{course_id_str}/info')

            df = pd.DataFrame({
                'Í≥ºÎ™© Î™Ö': course_names,
                'Í≥ºÎ™© ID': course_ids,
                'Í≥ºÎ™© URL': course_urls # https://salestest.elice.io/courses/36207/info
            })

            st.session_state['course_fetch_df'] = df
    else:
        st.info('[Í≥ºÎ™© Î∂àÎü¨Ïò§Í∏∞] Î≤ÑÌäºÏùÑ ÎàåÎü¨ÏÑú Í≥ºÎ™©ÏùÑ Î∂àÎü¨ÏòµÎãàÎã§.')

    gb = GridOptionsBuilder.from_dataframe(st.session_state['course_fetch_df'])
    gb.configure_pagination(paginationAutoPageSize=False, paginationPageSize=20)
    if not st.session_state['course_fetch_df'].empty:
        gb.configure_selection(selection_mode='multiple', use_checkbox=True)
        gb.configure_column('Í≥ºÎ™© Î™Ö', headerCheckboxSelection=True)

    gridOptions = gb.build()

    # when checkbox is selected update page and button status is set to false
    grid_table = AgGrid(st.session_state['course_fetch_df'], 
                        gridOptions=gridOptions, 
                        update_mode=GridUpdateMode.SELECTION_CHANGED,
                        columns_auto_size_mode=ColumnsAutoSizeMode.FIT_CONTENTS, 
                        theme='material')

    selected_course_rows = grid_table['selected_rows']
    selected_df = pd.DataFrame(selected_course_rows)
    logger.info(selected_course_rows)
    # st.write(st.session_state)

    st.write('#### 2Ô∏è‚É£ Í≥ºÎ™© ÏÑ†ÌÉùÌïòÍ∏∞', selected_df)
    st.info('üîº ÏúÑÏùò Í≥ºÎ™© Î™©Î°ùÏóêÏÑú Ïù¥Î¶ÑÏùÑ Î≥ÄÍ≤ΩÌï† Í≥ºÎ™©ÏùÑ Ï≤¥ÌÅ¨Î∞ïÏä§Î°ú ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî')

    st.write('#### 3Ô∏è‚É£ Î≥ÄÍ≤ΩÌïòÎ†§Îäî Í≥ºÎ™©Î™Ö ÏûÖÎ†•ÌïòÍ∏∞')
    st.info('üîΩ Î≥ÄÍ≤ΩÌïòÎ†§Îäî Í≥ºÎ™©Î™ÖÏùò ÏÖÄ Ï†ÑÏ≤¥Î•º Ï†ÑÏ≤¥ Î≥µÏÇ¨-Î∂ôÏó¨ÎÑ£Í∏∞ Í∞ÄÎä•Ìï©ÎãàÎã§.')

    if not selected_df.empty:
        selected_df['Î≥ÄÍ≤Ω Í≥ºÎ™©Î™Ö'] = ""
        to_edit_df = selected_df[['Í≥ºÎ™© Î™Ö', 'Í≥ºÎ™© ID', 'Î≥ÄÍ≤Ω Í≥ºÎ™©Î™Ö']]
    else: to_edit_df = pd.DataFrame()

    # edited_df = st.experimental_data_editor(to_edit_df, width=None)
    edited_df = st.data_editor(to_edit_df, width=None)

    # user report for update check
    # prev_name -> to_change_name
    if st.button("Í≥ºÎ™©Î™Ö Î∞îÍæ∏Í∏∞ üõé"): # check if no data in 'Î≥ÄÍ≤Ω Í≥ºÎ™©Î™Ö'
        if (edited_df['Î≥ÄÍ≤Ω Í≥ºÎ™©Î™Ö'] == '').any():
            st.warning('Î≥ÄÍ≤Ω Í≥ºÎ™©Î™ÖÏù¥ Î™®Îëê ÏûÖÎ†•ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. ‚õîÔ∏è')
        else:
            progress_text = "ÏöîÏ≤≠Ìïú Í≥ºÎ™©Î™Ö Î≥ÄÍ≤ΩÏùÑ ÏßÑÌñâÏ§ëÏûÖÎãàÎã§. üèÑ‚Äç‚ôÇÔ∏è"
            my_bar = st.progress(0, text=progress_text)

            for percent_complete in range(100):
                time.sleep(0.05)
                my_bar.progress(percent_complete + 1, text=progress_text)

            for _, row in edited_df.iterrows():
                prev_course_name = row['Í≥ºÎ™© Î™Ö']
                to_change_name = row['Î≥ÄÍ≤Ω Í≥ºÎ™©Î™Ö']
                course_id = row['Í≥ºÎ™© ID']
                edit_result_json = course_setting_edit_single(org_name, course_id, to_change_name, st.session_state['sessionkey'])
                logger.info(edit_result_json)
                logger.info(f"Í≥ºÎ™© Ïù¥Î¶Ñ Î≥ÄÍ≤Ω: {prev_course_name} -> {to_change_name}")
                st.info(f"Í≥ºÎ™© Ïù¥Î¶Ñ Î≥ÄÍ≤Ω: {prev_course_name}:{course_id} -> {to_change_name}")  
            my_bar.empty()
            st.success("ÏóÖÎç∞Ïù¥Ìä∏Î•º ÏôÑÎ£åÌñàÏäµÎãàÎã§. üéâ")                                
    else: st.info("üîº [Í≥ºÎ™©Î™Ö Î∞îÍæ∏Í∏∞ üõé] Î≤ÑÌäºÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî.")
